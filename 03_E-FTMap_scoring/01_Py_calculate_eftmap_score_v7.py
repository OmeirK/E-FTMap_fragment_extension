'''
Written By: Omeir Khan

Score ligand atoms based on their overlap with different pharmacophore clusters
A score associated with each E-FTMap cluster is defined as the size/max_cluster_size for 
clusters of a particular atom type

#### This code is modified from 01_Py_score_ligand_atoms_v4_mod.py ####
#### Log notes from the old script:                                #### 

v1: [X] Output a csv file with a score for each ligand in the lig_sdf file that is provided
        [X] Score aromatic atoms based on overlap of ring COG with ring pharm
        [X] Score apolar atoms based on overlap of carbon atoms bound to H or C with ring pharm
        [X] Score acceptor/donor/halogen atoms based on acceptor pharm overlap

v2: [X] Revise the apolar atom definition to include C,S atoms bound to anything except N and O
    [X] Read molecule names from the --lig_sdf file, and use these names in the output file

v3: [X] Create separate score files for diff measurements (Kd, Ki, IC50)
    [X] Create one output file which has ligand scores and p(BA) values

v4: [X] Define apolar atoms as any carbon or sulfur atom. I will disregard whatever it is bonded to.

########################################################################

v2: [X] Try to make small optimizations to the run time
v3: [X] Also calculate an E-FTMap "ligand efficiency
    [] Parallelize the calculation so that multiple files can be processed at once

v4: [X] Track the E-FTMap ACSs that were overlap with in each ligand
    [] Try to optimize the run time more

v5: [X] Treat PosIonizeable, NegIonizeable pharmacophore atoms as acceptors 
        and donors. PREVIOUSLY THESE WERE NOT SCORED !! ;w;
        I do not consider the ZnBinder type, because it is usually accompanied by
        a second atom type
v6: [X] Output the SMILES string of each ligand in the outfiles

v7: [] Change so that an output folder is provided, not an output file name
'''

import os
import tqdm
import argparse
import numpy as np
from rdkit import Chem
from rdkit import RDConfig
import multiprocessing as mp
from rdkit.Chem import ChemicalFeatures
from pymol import cmd, stored

parser = argparse.ArgumentParser()
parser.add_argument('--pharm_pdb', '-p', help='A .pdb file with the coordinates of pharmacophore clusters')
parser.add_argument('--sdf_dir', '-sd', help='A directory containing .sdf files with the ligands that you want to score. These files should be generated by 00_Py_combine_sdf_files_v2.py')
parser.add_argument('--radius', '-r', help='The overlap radius used for score calculation (default=1.5)', type=float, default=1.5)
parser.add_argument('--out_dir', '-od', help='The name of directory where .tsv files with E-FTMap scores will be stored (default = ./eftmap_scores)', default='./eftmap_scores')
parser.add_argument('--prefix', '-pre', help='A prefix to append to the start of output .tsv files (default = eftmap_scores)', default='eftmap_scores')
parser.add_argument('--n_cpus', '-cpu', help='The number of cpus/cores to use for the calculation. Increase to parallelize the scoring calculation. (default = 1)', default=1, type=int)

args = parser.parse_args()

# Define a score associated with each E-FTMap cluster
# The score is the size/max_size of a cluster for a given
# atom type
def define_clust_scores(eftmap_pdb):
    cmd.reinitialize()
    cmd.load(eftmap_pdb)

    score_dict = {} # Store a score associated with each cluster
    coord_dict = {}

    for at_type in ['acceptor', 'donor', 'apolar', 'aromatic', 'halogen']:
        score_dict[at_type] = {}
        coord_dict[at_type] = {}

        clust_objs = cmd.get_object_list(f'clust.*.{at_type}')
        
        # Get the max cluster size
        max_size = 0
        for obj in clust_objs:
            clust_data = obj.split('.')
            clust_size = int(clust_data[2])


            if clust_size > max_size:
                max_size = clust_size

        # Get scores for each cluster
        for obj in clust_objs:
            clust_data = obj.split('.')
            clust_size = int(clust_data[2])

            score = clust_size/max_size

            score_dict[at_type][obj] = score
            coords = cmd.get_coords(obj)
            coord_dict[at_type][obj] = coords

            #print('\t', obj, score)
            #print('\t', coords)
    
    return score_dict, coord_dict

# For each molecule in the sdf file, score atoms based on overlap
# with pharmacophore atoms. Return a list of the data that can be
# written to an output file
def score_atoms(lig_pharm_data, mol_list, score_dict, pharm_coord_data, lig_sdf, radius=1.5):
    outlines = ['Lig_Name\tMol_Idx\tMol_Smi\tTotal\tTotal_LE\tAcceptor\tDonor\tApolar\tAromatic\tHalogen\tOverlapping_ACSs\tOrigin_File\n']
    print('Scoring ligand poses...')
    for mol_id in tqdm.tqdm(lig_pharm_data):
        #lig_name = lig_names[mol_id]
        lig_name = mol_list[mol_id].GetProp('_Name')
        lig_hac = mol_list[mol_id].GetNumHeavyAtoms()
        lig_smi = Chem.MolToSmiles(mol_list[mol_id])
        lig_score = {'acceptor': 0, 'donor': 0, 'apolar': 0, 'aromatic': 0, 'halogen': 0}
        overlapping_acs_l = []
        for at_type in lig_pharm_data[mol_id]:
            for i, at_id in enumerate(lig_pharm_data[mol_id][at_type]['idx']):
                at_coord = lig_pharm_data[mol_id][at_type]['coords'][i]

                # Calculate if the ligand atom overlaps with E-FTMap ACS atoms
                for obj in pharm_coord_data[at_type]:
                    pharm_coords = pharm_coord_data[at_type][obj]

                    for pc in pharm_coords:
                        d = np.linalg.norm(pc - at_coord)
                        #print('\t', at_id, obj, d)
                        if d < radius:
                            lig_score[at_type] += score_dict[at_type][obj]
                            overlapping_acs_l.append(obj)
                            break
        
        tot_score = 0
        for at_type in lig_score:
            tot_score += lig_score[at_type]
        
        overlapping_acs_l = list(set(overlapping_acs_l))
        overlapping_acs_str = ''
        for i in overlapping_acs_l:
            overlapping_acs_str += f'{i},'

        overlapping_acs_str = overlapping_acs_str[:-1]
        #print(overlapping_acs_str)

        tot_le = tot_score/lig_hac
        outstr = f'{lig_name}\t{mol_id}\t{lig_smi}\t{tot_score:.4f}\t{tot_le:.4f}\t{lig_score["acceptor"]:.4f}\t{lig_score["donor"]:.4f}\t{lig_score["apolar"]:.4f}\t{lig_score["aromatic"]:.4f}\t{lig_score["halogen"]:.4f}\t{overlapping_acs_str}\t{lig_sdf}\n'
        outlines.append(outstr)
        #print(mol_id, tot_score, lig_score)

    return outlines

# Get the name of each ligand in the mols list
def get_lig_names(mols):
    name_l = []
    for mol in mols:
        name = mol.GetProp('_Name')
        if name == '':
            name = 'UNK' # Assign a generic name if none is given

        name_l.append(name)

    return name_l

# Get indices of ring atoms in each mol object
def get_ring_info(mols):
    ring_data = {}
    for i, mol in enumerate(mols):
        ri = mol.GetRingInfo()
        ring_data[i] = []
        for ring in ri.AtomRings():
            ring_data[i].append(ring)
        print(i, ring_data[i])

    return ring_data

# For each mol in a list, get the 3D coordinates
def get_mol_coords(mol):
    conf = mol.GetConformer()
    n_ats = mol.GetNumAtoms()
    coord_arr = np.zeros((n_ats,3))

    for at_id in range(0,n_ats):
        at_pos = conf.GetAtomPosition(at_id)

        coord_arr[at_id][0] = at_pos.x
        coord_arr[at_id][1] = at_pos.y
        coord_arr[at_id][2] = at_pos.z

        #print(at_id, coord_arr[at_id])
    
    
    return coord_arr

# Define chemical features that can be used
def detect_pharmacophore_atoms(mols):
    fdefName = os.path.join(RDConfig.RDDataDir,'BaseFeatures.fdef')
    factory = ChemicalFeatures.BuildFeatureFactory(fdefName)
    
    pharm_data = {}
    i = 0
    for mol in tqdm.tqdm(mols):
        pharm_data[i] = {'acceptor' : {'idx': [], 'coords': []},
                         'donor' : {'idx': [], 'coords' : []},
                         'apolar' : {'idx': [], 'coords': []},
                         'aromatic' : {'idx': [], 'coords': []},
                         'halogen' : {'idx': [], 'coords': []}}
        mol_coords = get_mol_coords(mol)

        # Get acceptor, donor, and aromatic atoms
        feats = factory.GetFeaturesForMol(mol)
        for j, feat in enumerate(feats):
            feat_atoms = feat.GetAtomIds()
            feat_type = feat.GetFamily()
            
            #print(j, feat_type, feat_atoms)
            if (feat_type == 'Acceptor') or (feat_type == 'NegIonizable'):
                for at_id in feat_atoms:
                    at_elem = mol.GetAtomWithIdx(at_id).GetSymbol()
                    # Only take O or N acceptors
                    if at_elem in ['O', 'N']:
                        pharm_data[i]['acceptor']['idx'].append(at_id)
                        pharm_data[i]['acceptor']['coords'].append(mol_coords[at_id])
            elif (feat_type == 'Donor') or (feat_type == 'PosIonizable'):
                for at_id in feat_atoms:
                    at_elem = mol.GetAtomWithIdx(at_id).GetSymbol()
                    # Only take O or N donors
                    if at_elem in ['O', 'N']:
                        pharm_data[i]['donor']['idx'].append(at_id)
                        pharm_data[i]['donor']['coords'].append(mol_coords[at_id])
            elif feat_type == 'Aromatic':
                for at_id in feat_atoms:
                    if at_id not in pharm_data[i]['aromatic']['idx']: # Rings can have overlapping atoms
                        pharm_data[i]['aromatic']['idx'].append(at_id)
                        pharm_data[i]['aromatic']['coords'].append(mol_coords[at_id])

        # Get halogen and apolar atoms
        for atom in mol.GetAtoms():
            at_id = atom.GetIdx()
            at_elem = atom.GetSymbol()

            #print(at_id, at_elem)

            if at_elem in ['C', 'S']:
                pharm_data[i]['apolar']['idx'].append(at_id)
                pharm_data[i]['apolar']['coords'].append(mol_coords[at_id])
            elif at_elem in ['F', 'Cl', 'Br', 'I']:
                pharm_data[i]['halogen']['idx'].append(at_id)
                pharm_data[i]['halogen']['coords'].append(mol_coords[at_id])
                
        i += 1

    return pharm_data

def mp_func(lig_sdf, pharm_pdb, radius, outfile):
    ## Collect info from the E-FTMap PDB ##
    print(f'Assigning scores to E-FTMap clusters...')   
    score_dict, pharm_coord_data = define_clust_scores(pharm_pdb)

    print(f'Reading molecules from the sdf...')   
    ## Collect info from the ligand sdf file ##
    lig_mols = Chem.SDMolSupplier(lig_sdf)
    
    print(f'\t{len(lig_mols)} poses to score...')

    print(f'Detecting pharmacophore atoms...')   
    lig_pharm_data = detect_pharmacophore_atoms(lig_mols)
    #lig_coord_data = get_mol_coords(lig_mols)
    
    print(f'Scoring ligands...')   
    score_lines = score_atoms(lig_pharm_data, lig_mols, score_dict, pharm_coord_data, lig_sdf, radius)
    
    print(f'Saving scores to {outfile}...')
    with open(outfile, 'w') as fo:
        fo.write(''.join(score_lines))

def main():
    # Prepare the input list
    sdf_ligs = os.listdir(args.sdf_dir)
    
    if os.path.exists(args.out_dir) == False:
        os.mkdir(args.out_dir)
    else:
        print(f'NOTE: {args.out_dir} already exists! Existing files starting with {args.prefix} might be overwritten!')

    mp_inps = []
    for sdf in sdf_ligs:
        if sdf[-4:] != '.sdf':
            continue

        sdf_path = os.path.abspath(f'{args.sdf_dir}/{sdf}')
        sdf_idx = sdf_path[:-4].split('_')[-1] # The last value should be the index of the file
        
        outfile = f'{args.out_dir}/{args.prefix}_{sdf_idx}.tsv'
        
        if os.path.exists(outfile):
            print(f'{outfile} already exists! Skipping scoring for poses in {sdf_path}')
            continue

        inp_tup = (sdf_path, args.pharm_pdb, args.radius, outfile)
        #print(inp_tup)
        mp_inps.append(inp_tup)
    
    with mp.Pool(args.n_cpus) as pool:
        pool.starmap(mp_func, mp_inps, chunksize=1)

    
if __name__=='__main__':
    main()

